#include <iostream>
#include <list>
#include <math.h>
using namespace std;


//converts key using midSquare algorithm, returns int
int midSquare(int key, int size){
    int hashCode = key * key;

    int mapBits = ((int)ceil(log2(size)));
    int totalBits = ((int)ceil(log2((3*size) * (3*size))));
    int mapOverTotal = ((int)pow(2, (totalBits - mapBits) / 2));
    hashCode /= mapOverTotal;
    hashCode %= size;

    return hashCode;
}

//converts key by modding the table size, returns int
int modSize(int key, int size){
    return key % size;
}


class HashChaining{

public:
    int collision = 0;
    const static int buckets = 100; //this value is the amount of total space allocated on the hash map
                                    //I change the number for each separate experiment's size.

    struct node{
        int key;
        node* next;
    };

    node* hashMap[buckets];

    HashChaining(){

        for (int i = 0; i < buckets; i++){
            hashMap[i] = new node;
            hashMap[i]->key = 5000;             //initializes empty key nodes as 5000 and next nodes to null
            hashMap[i]->next = nullptr;
        }
    }
    int getCollisions(){
        return collision;
    }



    int insertChaining(int key, int size){

        int index = midSquare(key, size);       //index is generated by using either the midsquare or mod-size method (above)

        if(hashMap[index]->key == 5000){
            hashMap[index]->key = key;          //if the key node has 5000, it is empty so I can insert
        }
        else{
            collision++;
            node* temp = hashMap[index];        //if the key node is not 5000, count a collision and
            node* newNode = new node;           //add a node to that index's list.
            newNode->key = key;
            newNode->next = nullptr;
            while(temp->next != nullptr){
                temp = temp->next;
            }
            temp-> next = newNode;

        }
        return collision;

    }

    void print(int size) {
        int counter;
        for (int i = 0; i < size; i++) {
            cout << "Index: " << i << endl;
            cout << "Key: " << hashMap[i]->key << endl;         //added the option to print out the hash map just
            node *temp = hashMap[i];                            //to confirm that the values were being placed in correctly
            while (temp->next != nullptr) {
            if (temp->next != nullptr) {
                cout << "Key: " << temp->next->key << endl;
                temp = temp->next;
            }

        }
            cout << endl;
        }
    }


};


class HashOpenAddress{
    int collision = 0;
public:
    void insertOpenAddress(int *map, int size, int key) {
        bool hasBeenInserted = false;

        int hashCode = midSquare(key, size);        //index is generated by using either the midsquare or mod-size method (above)

        if (map[hashCode]!= 5000){
            collision++;                            //if the key at the index generated is not 5000, meaning it has a key inserted there,
        }                                           //increment collision count.

        int count = 0;
        while (!hasBeenInserted) {
            if (map[hashCode] == 5000) {
                map[hashCode] = key;                //if the key at the index generated is 5000, meaning it is empty, insert the key.
                hasBeenInserted = true;
            } else {
                hashCode++;                         //if the key at the index generated is not 5000, meaning it is not empty,
                hashCode %= size;                   //increment the hash code and update it.

            }
        }


    }

    int getCollisions(){
        return collision;
    }

    //added the option to print out the hash map just to confirm that the values were being placed in correctly
    void printMap(int *map, int size) {
        for (int i = 0; i < size; i++) {

            cout << "Index: " << i << "--->" << "Key: " << map[i]<< endl;
        }
    }

    void createMap(int *map, int size) {
        for (int i = 0; i < size; i++) {
            map[i] = 5000;                  //creates a map and sets all empty indexes to 5000.
        }
    }

};


int main() {


    //The totalBuckets variable is the size of my map, and the fillAmount variable is how many keys I insert.
    //The load factor is simply how many keys I fill divided by the total amount of spots available.

    //This portion is for the Open Address experiments.
    HashOpenAddress testing;
    int totalBuckets = 100;
    float fillAmount = 50;
    float loadFactor = fillAmount / totalBuckets;
    int *map = new int[totalBuckets];
    testing.createMap(map, totalBuckets);       //creates array-map with the size chosen.

    int a = 0;
    while(a < fillAmount) {
        int key = rand() % (3 * totalBuckets);                  //this while loop inserts keys that range from
        testing.insertOpenAddress(map, totalBuckets, key);      //0-3*size and goes till the amount of keys I chose to fill.
        a++;
    }

    //testing.printMap(map, totalBuckets); //------------- option to print map to show that the keys have been inserted.
    cout << "Open Address Hashing"<< endl;
    cout << "Collisions: " << testing.getCollisions() << endl;
    cout << "Load factor: "<< loadFactor << endl;
    cout << endl;
    cout << endl;


    //This portion is for the Separate Chaining experiments.
    HashChaining test;

    int b = 0;
    while(b < fillAmount) {
        int key = rand() % (3 * totalBuckets);          //this while loop inserts keys that range from
        test.insertChaining(key, totalBuckets);         //0-3*size and goes till the amount of keys I chose to fill.
        b++;
    }

    //test.print(totalBuckets); ------------- option to print map to show that the keys have been inserted.
    cout << "Separate Chain Hashing"<< endl;
    cout << "Collisions: "<<test.getCollisions() << endl;
    cout << "Load factor: "<< loadFactor << endl;



}



